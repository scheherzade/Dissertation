\contentsline {figure}{\numberline {2.1}{\ignorespaces The effect of task size on execution time for Stencil application \cite {grubel2015performance}\relax }}{7}% 
\contentsline {figure}{\numberline {2.2}{\ignorespaces An example of the achievable speedup based on Amdahl's law and USL compared to the ideal linear speedup where $\sigma =0.04$ and $\kappa =0.005$.\relax }}{8}% 
\contentsline {figure}{\numberline {4.1}{\ignorespaces The results obtained from running $DMATDMATADD$ benchmark through Blazemark for matrix size 690$\times $690 on different number of cores.\relax }}{20}% 
\contentsline {figure}{\numberline {4.2}{\ignorespaces The results obtained from running $DMATDMATADD$ benchmark through Blazemark for matrix of size 690$\times $690 from two different angles\relax }}{21}% 
\contentsline {figure}{\numberline {4.3}{\ignorespaces The results obtained from running $DMATDMATADD$ benchmark through Blazemark for matrix sizes from 200$\times $200 to 1587$\times $1587\relax }}{22}% 
\contentsline {figure}{\numberline {4.4}{\ignorespaces The results obtained from running $DMATDMATADD$ benchmark through Blazemark for matrix size 690$\times $690 with different combinations of block size and chunk size on $4$ cores\relax }}{23}% 
\contentsline {figure}{\numberline {4.5}{\ignorespaces The results obtained from running $DMATDMATADD$ benchmark through Blazemark for matrix size 690$\times $690 on $4$ cores.\relax }}{24}% 
\contentsline {figure}{\numberline {4.6}{\ignorespaces Throughput vs. grain size graph obtained from running $DMATDMATADD$ benchmark on $4$ cores for matrix sizes (a) smaller than 793$\times $793 and (b) larger than 793$\times $793.\relax }}{25}% 
\addvspace {12\p@ }
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{25}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{25}% 
\contentsline {figure}{\numberline {4.7}{\ignorespaces The results of fitting the throughput vs grain size data into a 2d polynomial for $DMATDMATADD$ benchmark for matrix size 690$\times $690 with different number of cores on the test data set (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, (h) 8 cores.\relax }}{26}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{26}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{26}% 
\contentsline {figure}{\numberline {4.8}{\ignorespaces The training and test error for fitting data obtained from the $DMATDMATADD$ benchmark for matrix size $690\times 690$ against different number of cores cores.\relax }}{27}% 
\contentsline {figure}{\numberline {4.9}{\ignorespaces Fitting the parameters of the quadratic function with a $3$rd degree polynomial from the $DMATDMATADD$ benchmark for matrix size $690\times 690$ against different number of cores.\relax }}{28}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{28}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{28}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{28}% 
\contentsline {figure}{\numberline {4.10}{\ignorespaces The error in fitting the parameters $a$, $b$, and $c$ for matrix size $690\times 690$.\relax }}{28}% 
\contentsline {figure}{\numberline {4.11}{\ignorespaces Results of fitting the data from $DMATDMATADD$ benchmark with a polynomial of degree $2$ in terms of grain size and of degree $3$ in terms of number of cores for matrix size $690\times 690$ for (a) 2 core, (b) 4 cores, (c) 8 cores.\relax }}{29}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{29}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{29}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{29}% 
\contentsline {figure}{\numberline {4.12}{\ignorespaces The training and test error obtained fitting the data to a polynomial of degree $2$ in terms of grain size and of degree $3$ in terms of number of cores for matrix size $690\times 690$, for each number of cores. (a) All the data points are include in calculation of error, (b) the leftmost sample was removed from error calculation.\relax }}{29}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{29}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{29}% 
\contentsline {figure}{\numberline {4.13}{\ignorespaces The range of grain size (shown as the red line) that leads to a performance within $10\%$ of the maximum performance for (a) 2 cores, (b) 4 cores and (b) 8 cores.\relax }}{30}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{30}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{30}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{30}% 
\contentsline {figure}{\numberline {4.14}{\ignorespaces The range of grain size within $10\%$ of the maximum performance of the fitted polynomial function for $DMATDMATADD$ benchmark for different number of cores for (a) matrix size $690\times 690$ (b)matrix size $523\times 523$ to $912\times 912$.\relax }}{31}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{31}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{31}% 
\contentsline {figure}{\numberline {4.15}{\ignorespaces The range of chunk sizes to produce a grain size within $10\%$ of the maximum performance of the fitted quadratic function for $DMATDMATADD$ benchmark for matrix size $690\times 690$ with block size of $4\times 256$ on (a) $2$ cores, (b) $4$ cores, and (c) $8$ cores, and block size of $4\times 512$ on (d) $2$ cores, (e) $4$ cores, and (f) $8$ cores. Silver points denotes the detected range of chunk size, and the red star shows the median point.\relax }}{32}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{32}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{32}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{32}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{32}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{32}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{32}% 
\contentsline {figure}{\numberline {4.16}{\ignorespaces Throughput vs. grain size graph obtained from running $DMATDMATADD$ benchmark on $4$ cores.\relax }}{33}% 
\contentsline {figure}{\numberline {4.17}{\ignorespaces The range of grain size within $10\%$ of the maximum performance of the fitted polynomial function for $DMATDMATADD$ benchmark for different number of cores for matrix size $523\times 523$ to $912\times 912$.\relax }}{34}% 
\contentsline {figure}{\numberline {5.1}{\ignorespaces The way $w\_c$ is calculated illustrated for cases where $num\_{tasks}\%N=1$ and $num\_{iterations}\%chunk\_{size}\not =0$.\relax }}{39}% 
\contentsline {figure}{\numberline {5.2}{\ignorespaces The results of running the parallel for-loop benchmark with $problem\_size=3000$, on different (a)4 cores, and (b) 8 cores. The vertical dotted line shows the grain size that would generate same number of tasks as the number of cores, with the same amount of work for all the cores.\relax }}{42}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{42}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{42}% 
\contentsline {figure}{\numberline {5.3}{\ignorespaces The results of running the parallel for-loop benchmark with $problem\_size=100,000$, on 8 cores. The unit for execution time is microseconds.\relax }}{44}% 
\contentsline {figure}{\numberline {5.4}{\ignorespaces The results of running the parallel for-loop benchmark with $problem\_size=100000$, on 8 cores. (a) represents the graph in logarithmic scale, while (b) shows the same graph in linear scale. The unit for execution time is microseconds.\relax }}{47}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{47}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{47}% 
\contentsline {figure}{\numberline {5.5}{\ignorespaces The (a) relative error, and (b) $R^2$ score of fitting the collected data to the proposed analytical model for different $problem\_{sizes}$, calculated for each number of cores.\relax }}{48}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{48}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{48}% 
\contentsline {figure}{\numberline {5.6}{\ignorespaces The (a)relative error and (b)$R^2$ score of using the model parameters found from each base $problem\_{size}$ fitting the proposed analytical model to the collected data for different $problem\_{sizes}$, calculated over each number of cores.\relax }}{49}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{49}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{49}% 
\contentsline {figure}{\numberline {5.7}{\ignorespaces The results of running the parallel for-loop benchmark with $problem\_size=100000$, on different number of cores. The unit for execution time is microseconds.\relax }}{50}% 
\contentsline {figure}{\numberline {5.8}{\ignorespaces The results of predicted values of execution time through curve fitting vs the real data for $problem\_size=100000$, for (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, (h) 8 cores. The unit for execution time is microseconds.\relax }}{51}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{51}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{51}% 
\contentsline {figure}{\numberline {5.9}{\ignorespaces The results of predicted values of execution time through curve fitting vs the real data for $problem\_size=100000000$, for (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, (h) 8 cores. The unit for execution time is microseconds.\relax }}{52}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{52}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{52}% 
\contentsline {figure}{\numberline {5.10}{\ignorespaces The (a) relative error, and (b) $R^2$ score of fitting the collected data to the proposed analytical model for different $problem\_{sizes}$, calculated for each number of cores.\relax }}{53}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{53}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{53}% 
\contentsline {figure}{\numberline {5.11}{\ignorespaces The (a)relative error and (b)$R^2$ score of using the model parameters found from each base $problem\_{size}$ fitting the proposed analytical model to the collected data for different $problem\_{sizes}$, calculated over each number of cores.\relax }}{54}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{54}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{54}% 
\contentsline {figure}{\numberline {5.12}{\ignorespaces The results of predicted values of execution time through curve fitting vs the real data for $problem\_size=100000$, for (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, (h) 8 cores. The unit for execution time is microseconds.\relax }}{55}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{55}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{55}% 
\contentsline {figure}{\numberline {5.13}{\ignorespaces The imbalance ratio calculated for different grain sizes for $problem\_size=10000$, on 8 cores. At the area between each two green lines $k=\left \delimiter "42643A7 {\frac {num\_{tasks}}{N}}\right \delimiter "52653A8 $ is constant.\relax }}{61}% 
\contentsline {figure}{\numberline {5.14}{\ignorespaces The imbalance ratio alongside speedup for different grain sizes for $problem\_size=10000$, on 8 cores, where $k=\left \delimiter "42643A7 {\frac {num\_{tasks}}{N}}\right \delimiter "52653A8 $.\relax }}{61}% 
\contentsline {figure}{\numberline {5.15}{\ignorespaces The identified range of grain size for minimum execution time for $problem\_size=$ (a) 10000, (b) 100000, (c) 1000000, (d) 10000000, (e) 100000000, on 8 cores, with $\lambda _{s}=0.1$ and $\lambda _{b}=0.1$. The gray dashed line represents the grain size where work is equally divided among the cores, $\frac {problem\_size}{N}$. The unit for execution time is microseconds.\relax }}{64}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{64}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{64}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{64}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{64}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{64}% 
\contentsline {figure}{\numberline {5.16}{\ignorespaces An example of the effect of $\lambda _b$ and $\lambda _s$ on the borders of the identified region for minimum execution time due to change for $problem\_{size}=100000000$ and $N=8$. \relax }}{65}% 
\contentsline {figure}{\numberline {5.17}{\ignorespaces The results of predicting execution time using the suggested analytical model with parameters identified using the parallel for-loop benchmark compared to the original values for $matrix\_{size}=690$, ran on (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, and (h) 8 cores. The unit for execution time is microseconds.\relax }}{67}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{67}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{67}% 
\contentsline {figure}{\numberline {5.18}{\ignorespaces The results of predicting execution time using the suggested analytical model with parameters identified using the benchmark compared to the original values for $matrix\_{size}=4222$, ran on (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, and (h) 8 cores. The unit for execution time is microseconds.\relax }}{68}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{68}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{68}% 
\contentsline {figure}{\numberline {5.19}{\ignorespaces The relative error of using the predicting the execution time based on grain size for the $DMATDMATADD$ benchmark from $Blazemark$ suite. The relative error of all matrix sizes smaller than $953$ was averaged for each specific number of cores.\relax }}{69}% 
\contentsline {figure}{\numberline {5.20}{\ignorespaces The $R^2$ score of using the predicting the execution time based on grain size for the $DMATDMATADD$ benchmark from $Blazemark$ suite. The relative error of all matrix sizes smaller than $953$ was averaged for each specific number of cores.\relax }}{69}% 
\contentsline {figure}{\numberline {5.21}{\ignorespaces The results of predicted values of execution time through curve fitting vs the real data for $matrix\_size=$, for (a) 690, (b) 912, (c) 1825, (d) 3193, (e) 4222, (f) 4855, (g) 6420, on 8 cores, with $\lambda _{b}=0.01$ and $\lambda _{s}=0.5$. The unit for execution time is microseconds.\relax }}{71}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{71}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{71}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{71}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{71}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{71}% 
\contentsline {figure}{\numberline {5.22}{\ignorespaces The suggested range of chunk size for minimum execution time with $block\_{size}=4\times {256}$, for $matrix\_size=$, for (a) 690, (b) 912, (c) 1825, (d) 3193, (e) 4222, (f) 4855, (g) 6420, on 8 cores, when $\lambda _{s}=0.5$ and $\lambda _{b}=0.01$. The unit for execution time is microseconds.\relax }}{73}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{73}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{73}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{73}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{73}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{73}% 
\contentsline {figure}{\numberline {6.1}{\ignorespaces The results of running the hpx for loop using splittable tasks with all-cores and idle-cores split types compared with different grain sizes, for $problem\_size=10000$, for (a) 1 core, (b) 2 cores, (c) 3 cores, (d) 4 cores, (e) 5 cores, (f) 6 cores, (g) 7 cores, (h) 8 cores. The unit for execution time is microseconds.\relax }}{78}% 
\contentsline {subfigure}{\numberline {(a)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(b)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(c)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(d)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(e)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(f)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(g)}{\ignorespaces {}}}{78}% 
\contentsline {subfigure}{\numberline {(h)}{\ignorespaces {}}}{78}% 
\contentsline {figure}{\numberline {7.1}{\ignorespaces An example of the results obtained from running $DVECDVECADD$ benchmark through Blazemark\relax }}{80}% 
